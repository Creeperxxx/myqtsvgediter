# 内存池实现

## 概述
这是一个C++实现的自定义内存池，旨在比标准的`malloc`/`new`操作更高效地管理内存分配。该内存池在初始化时预先分配一大块内存，然后从该池中处理后续的分配请求，减少内存碎片并提高分配性能。

## 设计架构

### 核心组件

1. **KMemoryPoll** - 主内存池类，管理多个内存块
   - 管理总池大小和块大小
   - 协调跨所有块的分配
   - 提供内存操作的公共接口

2. **KMemoryBlock** - 表示内存池中的单个内存块
   - 管理一块连续的内存区域
   - 跟踪块内的已分配区域
   - 实现首次适应分配策略

3. **KBlockNode** - 表示内存块中的已分配段
   - 跟踪每个分配的起始地址和大小
   - 维护块内分配的双向链表

### 内存管理策略

- **预分配**：池在初始化时预先分配所有内存
- **基于块**：内存被划分为固定大小的块(可能有较小的最后一块)
- **首次适应分配**：找到能满足请求的第一个可用空间
- **显式释放**：必须由调用者显式释放内存

## 主要特性

1. **高效分配**：
   - 通过预分配内存减少系统调用
   - 通过块管理最小化碎片

2. **边界检查**：
   - 验证所有分配是否在池边界内
   - 防止双重释放和无效指针问题

3. **诊断工具**：
   - `printPollDetails()`提供内存使用情况洞察
   - 跟踪每个块的已用/空闲空间

4. **错误处理**：
   - 对无效操作抛出异常
   - 在初始化期间验证参数

## 使用方法

### 初始化
```cpp
KMemoryPoll pool(totalSize, blockSize);
```

### 分配内存
```cpp
void* ptr = pool.alloc(requestedSize);
```

### 释放内存
```cpp
bool success = pool.Free(ptr);
```

### 诊断信息
```cpp
pool.printPollDetails();
```

## 实现细节

1. **内存组织**：
   - 池由一个或多个`KMemoryBlock`对象组成
   - 每个块通过`KBlockNode`对象管理自己的分配
   - 节点形成双向链表跟踪块内的所有分配

2. **分配算法**：
   - 在块中搜索足够的连续空间
   - 使用首次适应策略查找可用内存
   - 按地址排序维护分配节点

3. **内存验证**：
   - 在释放前检查指针所有权
   - 验证所有操作是否保持在分配边界内

## 局限性

1. 固定最大大小(默认为10MB)
2. 无自动碎片整理
3. 基本的首次适应算法可能导致次优分配模式
4. 未实现线程安全

## 未来改进

1. 实现更复杂的分配策略(最佳适应、伙伴系统)
2. 添加碎片整理功能
3. 实现线程安全
4. 添加支持池大小调整
5. 实现更智能的块管理策略

## 示例

```cpp
KMemoryPoll pool(1024*1024, 256*1024); // 1MB池，256KB块

void* memory = pool.alloc(1000); // 分配1000字节
// 使用内存...
pool.Free(memory); // 释放内存

pool.printPollDetails(); // 查看使用统计
```

该实现为性能敏感型应用程序中的自定义内存管理提供了坚实基础，在这些应用中需要可预测的分配行为。。